---
id: FEATURE-030
type: feature
status: backlog
priority: high
complexity: small
created: 2026-02-05
updated: 2026-02-05
sprint: Sprint 6
estimated_hours: 2
dependencies: FEATURE-028, FEATURE-029
---

# Cost Tracking Verification & E2E Testing

## Problem/Opportunity
Cost tracking is implemented (FEATURE-028) and integrated (FEATURE-029), but we need verification that:
1. Tracking is working end-to-end
2. Costs are calculated accurately
3. Database writes are successful
4. Token counts are extracted correctly
5. Cache hits are tracked properly

Without verification, we can't trust the cost data in production.

## Proposed Solution
Create comprehensive verification tools:
1. Manual verification script for interactive testing
2. End-to-end integration tests
3. Cost accuracy validation
4. Database query verification

## User Story
As a developer, I want to verify cost tracking works correctly so that I can confidently deploy to production and trust the cost data.

## Acceptance Criteria
- [x] Verification script created at `scripts/verify_cost_tracking.py`
- [x] Script makes test LLM call and displays tracked data
- [x] E2E test suite created at `tests/integration/test_cost_tracking_e2e.py`
- [x] Tests validate full tracking pipeline
- [x] Cost calculations verified accurate
- [x] Database queries return expected data
- [x] All tests passing

## Dependencies
- FEATURE-028 (Cost Tracking Service) must be completed
- FEATURE-029 (LLM Integration) must be completed
- Access to MongoDB database
- Anthropic API key for real API calls

## Open Questions
- [x] Should verification script use real API or mocks? → Use real API with small prompt
- [x] Test with all models or just Haiku? → Test Haiku and Sonnet
- [x] How to verify cache hits? → Test with llm/cache.py integration

## Implementation Notes

### Verification Script

Create `scripts/verify_cost_tracking.py`:

```python
#!/usr/bin/env python3
"""
Cost tracking verification script.

Makes test LLM calls and verifies cost tracking is working correctly.
Displays tracked data and validates accuracy.

Usage:
    poetry run python scripts/verify_cost_tracking.py
"""

import asyncio
import os
import sys
from datetime import datetime, timezone
from motor.motor_asyncio import AsyncIOMotorClient
import certifi

# Add src to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))

from crypto_news_aggregator.llm.optimized_anthropic import OptimizedAnthropicProvider
from crypto_news_aggregator.services.cost_tracker import CostTracker, get_cost_tracker


async def verify_cost_tracking():
    """Run cost tracking verification."""
    
    print("="*60)
    print("         Cost Tracking Verification")
    print("="*60)
    print()
    
    # 1. Connect to MongoDB
    print("ℹ️  Connecting to MongoDB...")
    mongodb_uri = os.getenv("MONGODB_URI")
    if not mongodb_uri:
        print("❌ MONGODB_URI not set")
        return
    
    client = AsyncIOMotorClient(mongodb_uri, tlsCAFile=certifi.where())
    db = client["crypto_news"]
    print("✅ Connected to MongoDB")
    print()
    
    # 2. Get cost tracker
    print("ℹ️  Initializing cost tracker...")
    tracker = get_cost_tracker(db)
    print("✅ Cost tracker initialized")
    print()
    
    # 3. Make test LLM call
    print("ℹ️  Making test LLM call...")
    print("   Model: claude-3-5-haiku-20241022")
    print("   Operation: verification_test")
    print()
    
    api_key = os.getenv("ANTHROPIC_API_KEY")
    if not api_key:
        print("❌ ANTHROPIC_API_KEY not set")
        client.close()
        return
    
    provider = OptimizedAnthropicProvider(api_key=api_key)
    
    test_prompt = "Say 'Cost tracking verification successful' in 5 words or less."
    
    try:
        response_text = await provider.generate_completion(
            prompt=test_prompt,
            model="claude-3-5-haiku-20241022",
            max_tokens=50,
            operation="verification_test"
        )
        
        print(f"✅ LLM call succeeded")
        print(f"   Response: {response_text}")
        print()
    except Exception as e:
        print(f"❌ LLM call failed: {e}")
        client.close()
        return
    
    # 4. Wait for tracking to complete (async task)
    print("ℹ️  Waiting for cost tracking to complete...")
    await asyncio.sleep(2)  # Give time for async tracking
    print()
    
    # 5. Query database for tracked call
    print("ℹ️  Querying database for tracked call...")
    cutoff = datetime.now(timezone.utc)
    cutoff = cutoff.replace(second=cutoff.second - 10)  # Last 10 seconds
    
    doc = await db.api_costs.find_one(
        {
            "operation": "verification_test",
            "timestamp": {"$gte": cutoff}
        },
        sort=[("timestamp", -1)]
    )
    
    if not doc:
        print("❌ No tracked call found in database")
        print("   Check if cost tracking is integrated correctly")
        client.close()
        return
    
    print("✅ Found tracked call in database")
    print()
    
    # 6. Display tracked data
    print("="*60)
    print("         Tracked Call Details")
    print("="*60)
    print()
    print(f"Timestamp:      {doc['timestamp']}")
    print(f"Operation:      {doc['operation']}")
    print(f"Model:          {doc['model']}")
    print(f"Input Tokens:   {doc['input_tokens']}")
    print(f"Output Tokens:  {doc['output_tokens']}")
    print(f"Cost (USD):     ${doc['cost']:.6f}")
    print(f"Cached:         {doc['cached']}")
    print()
    
    # 7. Verify cost calculation
    print("="*60)
    print("         Cost Calculation Verification")
    print("="*60)
    print()
    
    expected_cost = tracker.calculate_cost(
        model=doc['model'],
        input_tokens=doc['input_tokens'],
        output_tokens=doc['output_tokens']
    )
    
    print(f"Tracked Cost:   ${doc['cost']:.6f}")
    print(f"Expected Cost:  ${expected_cost:.6f}")
    
    if abs(doc['cost'] - expected_cost) < 0.000001:
        print("✅ Cost calculation is accurate")
    else:
        print(f"❌ Cost mismatch: {abs(doc['cost'] - expected_cost):.6f}")
    print()
    
    # 8. Get monthly cost summary
    print("="*60)
    print("         Monthly Cost Summary")
    print("="*60)
    print()
    
    monthly_cost = await tracker.get_monthly_cost()
    daily_cost = await tracker.get_daily_cost(days=1)
    
    print(f"Month-to-Date:  ${monthly_cost:.4f}")
    print(f"Last 24 Hours:  ${daily_cost:.4f}")
    print()
    
    # 9. Get operation breakdown
    print("="*60)
    print("         Cost Breakdown (Last 24h)")
    print("="*60)
    print()
    
    from datetime import timedelta
    cutoff_24h = datetime.now(timezone.utc) - timedelta(hours=24)
    
    pipeline = [
        {"$match": {"timestamp": {"$gte": cutoff_24h}}},
        {"$group": {
            "_id": "$operation",
            "total_cost": {"$sum": "$cost"},
            "call_count": {"$sum": 1},
            "cached_count": {"$sum": {"$cond": ["$cached", 1, 0]}}
        }},
        {"$sort": {"total_cost": -1}}
    ]
    
    results = await db.api_costs.aggregate(pipeline).to_list(None)
    
    if results:
        for r in results:
            print(f"{r['_id']:20s} ${r['total_cost']:.4f} ({r['call_count']} calls, {r['cached_count']} cached)")
    else:
        print("No operations in last 24 hours")
    print()
    
    # 10. Success summary
    print("="*60)
    print("         Verification Complete")
    print("="*60)
    print()
    print("✅ Cost tracking is working correctly")
    print("✅ Database writes successful")
    print("✅ Cost calculations accurate")
    print()
    print("Next steps:")
    print("  1. Deploy to production")
    print("  2. Monitor costs in dashboard")
    print("  3. Set up alerts for daily cost > $0.50")
    print()
    
    client.close()


if __name__ == "__main__":
    asyncio.run(verify_cost_tracking())
```

### End-to-End Test Suite

Create `tests/integration/test_cost_tracking_e2e.py`:

```python
"""
End-to-end tests for cost tracking pipeline.

Tests the full flow from LLM call to database persistence.
"""

import pytest
import os
from datetime import datetime, timezone, timedelta
from motor.motor_asyncio import AsyncIOMotorClient
import certifi


@pytest.fixture
async def db():
    """Create test database connection."""
    mongodb_uri = os.getenv("MONGODB_URI")
    if not mongodb_uri:
        pytest.skip("MONGODB_URI not set")
    
    client = AsyncIOMotorClient(mongodb_uri, tlsCAFile=certifi.where())
    db = client["crypto_news_test"]
    
    yield db
    
    # Cleanup
    await db.api_costs.delete_many({})
    client.close()


@pytest.mark.asyncio
@pytest.mark.integration
class TestCostTrackingE2E:
    """End-to-end cost tracking tests."""
    
    async def test_llm_call_tracked_to_database(self, db):
        """Test that LLM calls are tracked to database."""
        from crypto_news_aggregator.llm.optimized_anthropic import OptimizedAnthropicProvider
        
        api_key = os.getenv("ANTHROPIC_API_KEY")
        if not api_key:
            pytest.skip("ANTHROPIC_API_KEY not set")
        
        # Make LLM call
        provider = OptimizedAnthropicProvider(api_key=api_key)
        response = await provider.generate_completion(
            prompt="Say 'test' in one word.",
            model="claude-3-5-haiku-20241022",
            max_tokens=10,
            operation="e2e_test"
        )
        
        # Wait for async tracking
        import asyncio
        await asyncio.sleep(2)
        
        # Query database
        cutoff = datetime.now(timezone.utc) - timedelta(seconds=10)
        doc = await db.api_costs.find_one(
            {
                "operation": "e2e_test",
                "timestamp": {"$gte": cutoff}
            },
            sort=[("timestamp", -1)]
        )
        
        # Verify tracking
        assert doc is not None, "LLM call not tracked to database"
        assert doc["model"] == "claude-3-5-haiku-20241022"
        assert doc["input_tokens"] > 0
        assert doc["output_tokens"] > 0
        assert doc["cost"] > 0
        assert doc["cached"] is False
    
    async def test_cache_hit_tracked_correctly(self, db):
        """Test that cache hits are tracked with zero cost."""
        # This test requires cache integration
        # For now, just verify the tracking logic
        
        from crypto_news_aggregator.services.cost_tracker import get_cost_tracker
        
        tracker = get_cost_tracker(db)
        
        # Track a cache hit
        cost = await tracker.track_call(
            operation="e2e_cache_test",
            model="claude-3-5-haiku-20241022",
            input_tokens=100,
            output_tokens=50,
            cached=True,
            cache_key="test_key"
        )
        
        # Cost should be zero
        assert cost == 0.0
        
        # Verify database entry
        doc = await db.api_costs.find_one({"cache_key": "test_key"})
        assert doc is not None
        assert doc["cached"] is True
        assert doc["cost"] == 0.0
    
    async def test_cost_aggregation_accurate(self, db):
        """Test that cost aggregation queries work correctly."""
        from crypto_news_aggregator.services.cost_tracker import get_cost_tracker
        
        tracker = get_cost_tracker(db)
        
        # Track multiple calls
        await tracker.track_call("test_op", "claude-3-5-haiku-20241022", 1000, 1000, False)
        await tracker.track_call("test_op", "claude-3-5-haiku-20241022", 1000, 1000, False)
        await tracker.track_call("test_op", "claude-3-5-haiku-20241022", 1000, 1000, True)  # Cache hit
        
        # Get daily cost
        daily_cost = await tracker.get_daily_cost(days=1)
        
        # Should be 2 × $0.0048 = $0.0096 (cache hit doesn't count)
        assert daily_cost == pytest.approx(0.0096, abs=0.0001)
    
    async def test_multiple_operations_tracked(self, db):
        """Test that different operations are tracked separately."""
        from crypto_news_aggregator.services.cost_tracker import get_cost_tracker
        
        tracker = get_cost_tracker(db)
        
        # Track different operations
        await tracker.track_call("entity_extraction", "claude-3-5-haiku-20241022", 500, 200, False)
        await tracker.track_call("briefing_generation", "claude-3-5-sonnet-20241022", 2000, 1000, False)
        await tracker.track_call("narrative_summary", "claude-3-5-haiku-20241022", 800, 300, False)
        
        # Query by operation
        entity_cost = await db.api_costs.aggregate([
            {"$match": {"operation": "entity_extraction"}},
            {"$group": {"_id": None, "total": {"$sum": "$cost"}}}
        ]).to_list(1)
        
        briefing_cost = await db.api_costs.aggregate([
            {"$match": {"operation": "briefing_generation"}},
            {"$group": {"_id": None, "total": {"$sum": "$cost"}}}
        ]).to_list(1)
        
        # Verify separate tracking
        assert entity_cost[0]["total"] > 0
        assert briefing_cost[0]["total"] > 0
        assert briefing_cost[0]["total"] > entity_cost[0]["total"]  # Sonnet more expensive
```

### Verification Checklist

Run these checks after implementation:

1. **Manual Verification**
   ```bash
   poetry run python scripts/verify_cost_tracking.py
   ```
   - ✅ LLM call succeeds
   - ✅ Database entry created
   - ✅ Cost calculation accurate
   - ✅ Monthly summary displays

2. **Integration Tests**
   ```bash
   pytest tests/integration/test_cost_tracking_e2e.py -v
   ```
   - ✅ All tests passing
   - ✅ Database writes verified
   - ✅ Aggregation queries work

3. **Database Check**
   ```bash
   # MongoDB shell
   use crypto_news
   db.api_costs.find().sort({timestamp: -1}).limit(5)
   ```
   - ✅ Recent entries exist
   - ✅ All fields populated
   - ✅ Costs look reasonable

4. **Dashboard Check**
   - Open Cost Monitor page
   - ✅ Data displays
   - ✅ Charts render
   - ✅ Numbers look accurate

## Completion Summary
*To be filled in after implementation*

- Actual complexity:
- Key findings:
- Issues discovered:
- Accuracy validation results: