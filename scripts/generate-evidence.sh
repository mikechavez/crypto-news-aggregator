#!/usr/bin/env bash
set -euo pipefail

# scripts/generate-evidence.sh
# Generate evidence pack for system documentation
# Collects key patterns and implementation details using ripgrep
# This script is self-contained and works in CI/clean environments

# Find ripgrep - supports both standalone binary and Claude Code CLI
RG_CMD=""

# Try standalone binary first
if command -v rg >/dev/null 2>&1 && rg --version >/dev/null 2>&1; then
    RG_CMD="rg"
# Fall back to Claude Code CLI ripgrep
elif [[ -x "/Users/mc/.local/share/claude/versions/2.1.38" ]]; then
    RG_CMD="/Users/mc/.local/share/claude/versions/2.1.38 --ripgrep"
fi

if [[ -z "$RG_CMD" ]]; then
    echo "ERROR: ripgrep (rg) is required but not found"
    echo "Install: brew install ripgrep (macOS) or apt install ripgrep (Linux)"
    exit 1
fi

# Ensure we're running from git repo root for consistent paths
ROOT="$(git rev-parse --show-toplevel 2>/dev/null)" || {
    echo "ERROR: Must run from within a git repository"
    exit 1
}
cd "$ROOT"

# Define search tool array - handle both simple command and command with args
eval "RG=($RG_CMD)"
RG+=(--no-heading --with-filename -n)

OUTPUT_DIR="docs/_generated/evidence"
mkdir -p "$OUTPUT_DIR"

echo "Generating evidence pack from: $ROOT"
echo ""

# Helper function to write header + search results
generate_evidence() {
    local file="$1"
    local description="$2"
    local pattern="$3"
    shift 3
    local extra_args=("$@")

    local filepath="$OUTPUT_DIR/$file.txt"

    echo "  üìÑ $file..."

    # Write 3-line header
    cat > "$filepath" << EOF
# $description
# Generated by: $RG_CMD -n '$pattern' ${extra_args[*]}
#

EOF

    # Append search results
    "${RG[@]}" "$pattern" "${extra_args[@]}" >> "$filepath" || true
}

echo "üîç Generating evidence pack..."
echo ""

# Generate all 12 evidence files
echo "üìç Entrypoints..."
generate_evidence "01-entrypoints" "Application entry points and server initialization" 'if __name__|FastAPI|@app\.' --type py .

echo "‚è∞ Celery & Scheduling..."
generate_evidence "02-celery-registration" "Celery task registration" '@shared_task|@celery\.task|@app\.task' --type py .
generate_evidence "02-celery-beat" "Scheduled task configuration (Celery Beat)" 'beat_schedule|periodic_task|crontab|CELERY_BEAT' --type py .

echo "üóÑÔ∏è  MongoDB..."
generate_evidence "03-mongo-init" "MongoDB client initialization" 'mongo_manager|MongoClient|motor_asyncio|get_db' --type py .
generate_evidence "03-mongo-collections" "Database collection usage patterns" 'db\[|get_collection|collection_name|briefing' --type py .

echo "üß† LLM Integration..."
generate_evidence "04-llm-client" "LLM client initialization" 'Anthropic|anthropic|get_llm_provider|claude' --type py .
generate_evidence "04-llm-prompts" "Prompt construction and message formatting" 'system_prompt|messages|SystemMessage|content' --type py .

echo "üì∞ Briefing Generation..."
generate_evidence "05-briefing-generation" "Briefing agent workflow" 'BriefingAgent|generate_briefing|briefing_agent' --type py .
generate_evidence "05-briefing-save" "Database persistence operations for briefings" 'save_briefing|insert_one|update_one|publish' --type py .

echo "üåê Frontend Routing..."
# Note: Some ripgrep versions don't support tsx type, so we search all files
generate_evidence "06-frontend-routes" "Frontend routing patterns" 'useRouter|useNavigate|Route|path|navigate' .

echo "‚ö†Ô∏è  Error Handling..."
generate_evidence "07-error-handlers" "Exception handling patterns" 'except|raise|logger\.error|RuntimeError' --type py .

echo "‚öôÔ∏è  Configuration..."
generate_evidence "08-config" "Configuration and settings" 'settings|Config|environ|get_settings' --type py .

echo ""
echo "üìö Validation..."
echo ""

# Validation: exit non-zero if any file is missing or empty
EXPECTED_FILES=(01-entrypoints 02-celery-registration 02-celery-beat 03-mongo-init 03-mongo-collections 04-llm-client 04-llm-prompts 05-briefing-generation 05-briefing-save 06-frontend-routes 07-error-handlers 08-config)
FAILED=0
for file in "${EXPECTED_FILES[@]}"; do
    filepath="$OUTPUT_DIR/${file}.txt"
    if [[ ! -f "$filepath" ]]; then
        echo "ERROR: Missing file: $filepath"
        FAILED=1
    elif [[ ! -s "$filepath" ]]; then
        echo "ERROR: Empty file: $filepath"
        FAILED=1
    else
        line_count=$(wc -l < "$filepath")
        echo "‚úÖ $file.txt ($line_count lines)"
    fi
done

if [[ $FAILED -eq 1 ]]; then
    echo ""
    echo "ERROR: Evidence generation failed validation"
    exit 1
fi

echo ""
echo "‚úÖ Evidence pack generated successfully!"
echo ""
echo "üìä Summary:"
wc -l "$OUTPUT_DIR"/*.txt | tail -1
echo ""
echo "üí° Next step: Use these files to generate system documentation"
echo "   Example: docs/_generated/system/20-scheduling.md uses 02-celery-*.txt"
