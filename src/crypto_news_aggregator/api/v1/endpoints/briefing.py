"""
Briefing API endpoints.

Provides access to daily crypto briefings generated by the briefing agent.
"""

import logging
from datetime import datetime, timezone, timedelta
from typing import List, Optional, Dict, Any
from fastapi import APIRouter, Query, HTTPException
from pydantic import BaseModel, Field

from ....db.mongodb import mongo_manager
from ....db.operations.briefing import (
    get_latest_briefing,
    get_briefing_by_type_and_date,
    get_briefings_last_n_days,
    insert_manual_input,
    get_pending_manual_inputs,
    mark_manual_input_used,
    delete_manual_input,
)
from ....services.memory_manager import get_memory_manager

logger = logging.getLogger(__name__)

router = APIRouter()


# =============================================================================
# Response Models
# =============================================================================


class BriefingRecommendation(BaseModel):
    """Recommended reading item."""

    title: str = Field(..., description="Narrative or article title")
    theme: str = Field(..., description="Theme category")
    narrative_id: Optional[str] = Field(None, description="Linked narrative ID if available")


class BriefingContent(BaseModel):
    """Content section of a briefing."""

    narrative: str = Field(..., description="Main briefing narrative text")
    key_insights: List[str] = Field(default=[], description="Key takeaways from the briefing")
    entities_mentioned: List[str] = Field(default=[], description="Entities discussed in briefing")
    detected_patterns: List[str] = Field(default=[], description="Patterns detected by agent")
    recommendations: List[BriefingRecommendation] = Field(
        default=[], description="Recommended reading"
    )


class BriefingMetadata(BaseModel):
    """Metadata about briefing generation."""

    confidence_score: float = Field(
        default=0.7, ge=0.0, le=1.0, description="Agent confidence in briefing quality"
    )
    signal_count: int = Field(default=0, description="Number of signals analyzed")
    narrative_count: int = Field(default=0, description="Number of narratives analyzed")
    pattern_count: int = Field(default=0, description="Number of patterns detected")
    manual_input_count: int = Field(default=0, description="Number of manual inputs used")
    model: Optional[str] = Field(None, description="LLM model used for generation")


class BriefingResponse(BaseModel):
    """Response model for a briefing."""

    id: Optional[str] = Field(default=None, alias="_id", description="MongoDB ObjectId as string")
    type: str = Field(..., description="Briefing type: 'morning' or 'evening'")
    generated_at: str = Field(..., description="ISO timestamp when briefing was generated")
    version: str = Field(default="2.0", description="Briefing format version")
    content: BriefingContent = Field(..., description="Briefing content")
    metadata: BriefingMetadata = Field(..., description="Generation metadata")

    class Config:
        populate_by_name = True


class ManualInputCreate(BaseModel):
    """Request model for creating a manual input."""

    title: str = Field(..., description="Title of the external source")
    source_type: str = Field(
        ...,
        description="Type of source: blog, tweet, report, newsletter, other",
    )
    content: str = Field(..., description="Content or summary of the source")
    url: Optional[str] = Field(None, description="URL to the original source")
    admin_notes: Optional[str] = Field(None, description="Admin notes about this input")


class ManualInputResponse(BaseModel):
    """Response model for a manual input."""

    id: str = Field(..., alias="_id", description="MongoDB ObjectId as string")
    title: str
    source_type: str
    content: str
    url: Optional[str] = None
    admin_notes: Optional[str] = None
    status: str = Field(..., description="pending, used, or expired")
    added_at: str = Field(..., description="ISO timestamp when added")
    expires_at: str = Field(..., description="ISO timestamp when it expires")

    class Config:
        populate_by_name = True


class NextBriefingResponse(BaseModel):
    """Response model for next briefing timing."""

    next_type: str = Field(..., description="Type of next briefing: 'morning' or 'evening'")
    next_time_utc: str = Field(..., description="ISO timestamp of next briefing in UTC")
    next_time_est: str = Field(..., description="ISO timestamp of next briefing in EST")
    hours_until: float = Field(..., description="Hours until next briefing")


class LatestBriefingResponse(BaseModel):
    """Wrapper response for latest briefing endpoint."""

    briefing: Optional[BriefingResponse] = Field(None, description="The briefing or null")
    next_briefing_at: str = Field(..., description="ISO timestamp for next scheduled briefing")


# =============================================================================
# Helper Functions
# =============================================================================


def _format_briefing(briefing: Dict[str, Any]) -> Dict[str, Any]:
    """Format a briefing document for API response."""
    generated_at = briefing.get("generated_at")
    if generated_at:
        generated_at_str = (
            generated_at.isoformat()
            if hasattr(generated_at, "isoformat")
            else str(generated_at)
        )
    else:
        generated_at_str = datetime.now(timezone.utc).isoformat()

    content = briefing.get("content", {})
    metadata = briefing.get("metadata", {})

    # Handle recommendations format
    recommendations = content.get("recommendations", [])
    formatted_recommendations = []
    for rec in recommendations:
        if isinstance(rec, dict):
            formatted_recommendations.append({
                "title": rec.get("title", ""),
                "theme": rec.get("theme", ""),
                "narrative_id": rec.get("narrative_id"),
            })

    return {
        "_id": str(briefing.get("_id", "")),
        "type": briefing.get("type", "morning"),
        "generated_at": generated_at_str,
        "version": briefing.get("version", "2.0"),
        "content": {
            "narrative": content.get("narrative", ""),
            "key_insights": content.get("key_insights", []),
            "entities_mentioned": content.get("entities_mentioned", []),
            "detected_patterns": content.get("detected_patterns", []),
            "recommendations": formatted_recommendations,
        },
        "metadata": {
            "confidence_score": metadata.get("confidence_score", 0.7),
            "signal_count": metadata.get("signal_count", 0),
            "narrative_count": metadata.get("narrative_count", 0),
            "pattern_count": metadata.get("pattern_count", 0),
            "manual_input_count": metadata.get("manual_input_count", 0),
            "model": metadata.get("model"),
        },
    }


def _calculate_next_briefing_time() -> Dict[str, Any]:
    """Calculate when the next briefing will be generated."""
    import pytz

    now = datetime.now(timezone.utc)
    est = pytz.timezone("America/New_York")
    now_est = now.astimezone(est)

    # Briefing times: 8 AM and 8 PM EST
    morning_time = now_est.replace(hour=8, minute=0, second=0, microsecond=0)
    evening_time = now_est.replace(hour=20, minute=0, second=0, microsecond=0)

    if now_est < morning_time:
        # Before morning briefing
        next_briefing = morning_time
        next_type = "morning"
    elif now_est < evening_time:
        # Between morning and evening
        next_briefing = evening_time
        next_type = "evening"
    else:
        # After evening briefing - next is tomorrow morning
        next_briefing = morning_time + timedelta(days=1)
        next_type = "morning"

    hours_until = (next_briefing - now_est).total_seconds() / 3600

    return {
        "next_type": next_type,
        "next_time_utc": next_briefing.astimezone(timezone.utc).isoformat(),
        "next_time_est": next_briefing.isoformat(),
        "hours_until": round(hours_until, 1),
    }


# =============================================================================
# Endpoints
# =============================================================================


@router.get("", response_model=LatestBriefingResponse)
async def get_latest_briefing_endpoint():
    """
    Get the most recent briefing (morning or evening).

    Returns the latest generated briefing regardless of type,
    wrapped with next briefing timing information.

    Returns:
        LatestBriefingResponse with briefing and next_briefing_at
    """
    try:
        briefing = await get_latest_briefing()
        next_briefing = _calculate_next_briefing_time()

        if not briefing:
            # Return null briefing when none exist yet
            return LatestBriefingResponse(
                briefing=None,
                next_briefing_at=next_briefing["next_time_utc"],
            )

        formatted = _format_briefing(briefing)
        return LatestBriefingResponse(
            briefing=BriefingResponse(**formatted),
            next_briefing_at=next_briefing["next_time_utc"],
        )

    except Exception as e:
        logger.exception(f"Error fetching latest briefing: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch briefing")


@router.get("/morning", response_model=BriefingResponse)
async def get_morning_briefing_endpoint(
    date: Optional[str] = Query(
        None, description="Date in YYYY-MM-DD format (defaults to today)"
    ),
):
    """
    Get the morning briefing for a specific date.

    Args:
        date: Date in YYYY-MM-DD format (defaults to today)

    Returns:
        BriefingResponse with the morning briefing content

    Raises:
        404: If no morning briefing exists for the specified date
    """
    try:
        if date:
            target_date = datetime.strptime(date, "%Y-%m-%d").replace(tzinfo=timezone.utc)
        else:
            target_date = datetime.now(timezone.utc)

        briefing = await get_briefing_by_type_and_date("morning", target_date)

        if not briefing:
            raise HTTPException(
                status_code=404,
                detail=f"No morning briefing found for {target_date.strftime('%Y-%m-%d')}",
            )

        formatted = _format_briefing(briefing)
        return BriefingResponse(**formatted)

    except HTTPException:
        raise
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid date format. Use YYYY-MM-DD")
    except Exception as e:
        logger.exception(f"Error fetching morning briefing: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch briefing")


@router.get("/evening", response_model=BriefingResponse)
async def get_evening_briefing_endpoint(
    date: Optional[str] = Query(
        None, description="Date in YYYY-MM-DD format (defaults to today)"
    ),
):
    """
    Get the evening briefing for a specific date.

    Args:
        date: Date in YYYY-MM-DD format (defaults to today)

    Returns:
        BriefingResponse with the evening briefing content

    Raises:
        404: If no evening briefing exists for the specified date
    """
    try:
        if date:
            target_date = datetime.strptime(date, "%Y-%m-%d").replace(tzinfo=timezone.utc)
        else:
            target_date = datetime.now(timezone.utc)

        briefing = await get_briefing_by_type_and_date("evening", target_date)

        if not briefing:
            raise HTTPException(
                status_code=404,
                detail=f"No evening briefing found for {target_date.strftime('%Y-%m-%d')}",
            )

        formatted = _format_briefing(briefing)
        return BriefingResponse(**formatted)

    except HTTPException:
        raise
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid date format. Use YYYY-MM-DD")
    except Exception as e:
        logger.exception(f"Error fetching evening briefing: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch briefing")


@router.get("/history", response_model=List[BriefingResponse])
async def get_briefing_history_endpoint(
    days: int = Query(7, ge=1, le=30, description="Number of days of history to return"),
):
    """
    Get briefing history for the last N days.

    Args:
        days: Number of days to look back (1-30, default 7)

    Returns:
        List of briefings, sorted by most recent first
    """
    try:
        briefings = await get_briefings_last_n_days(days=days)

        if not briefings:
            return []

        return [BriefingResponse(**_format_briefing(b)) for b in briefings]

    except Exception as e:
        logger.exception(f"Error fetching briefing history: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch briefing history")


@router.get("/next", response_model=NextBriefingResponse)
async def get_next_briefing_time_endpoint():
    """
    Get the scheduled time for the next briefing.

    Returns information about when the next briefing will be generated,
    including both UTC and EST timestamps.

    Returns:
        NextBriefingResponse with timing information
    """
    try:
        next_briefing = _calculate_next_briefing_time()
        return NextBriefingResponse(**next_briefing)
    except Exception as e:
        logger.exception(f"Error calculating next briefing time: {e}")
        raise HTTPException(status_code=500, detail="Failed to calculate next briefing time")


# =============================================================================
# Admin Endpoints
# =============================================================================


class GenerateBriefingRequest(BaseModel):
    """Request to manually generate a briefing."""

    type: str = Field("morning", description="Briefing type: 'morning' or 'evening'")
    force: bool = Field(True, description="Force generation even if one exists today")


class GenerateBriefingResponse(BaseModel):
    """Response from manual briefing generation."""

    success: bool
    message: str
    briefing_id: Optional[str] = None


@router.post("/generate", response_model=GenerateBriefingResponse)
async def generate_briefing_endpoint(request: GenerateBriefingRequest):
    """
    Manually trigger briefing generation.

    This endpoint allows admins to manually generate a briefing without
    waiting for the scheduled Celery Beat task.

    Args:
        request: Generation parameters (type, force)

    Returns:
        GenerateBriefingResponse with success status and briefing ID
    """
    from ....services.briefing_agent import generate_morning_briefing, generate_evening_briefing

    try:
        if request.type == "morning":
            briefing = await generate_morning_briefing(force=request.force)
        elif request.type == "evening":
            briefing = await generate_evening_briefing(force=request.force)
        else:
            raise HTTPException(status_code=400, detail="Invalid briefing type. Use 'morning' or 'evening'")

        if briefing:
            return GenerateBriefingResponse(
                success=True,
                message=f"Successfully generated {request.type} briefing",
                briefing_id=str(briefing.get("_id")),
            )
        else:
            return GenerateBriefingResponse(
                success=False,
                message="Briefing generation returned no result (may already exist today)",
                briefing_id=None,
            )

    except Exception as e:
        logger.exception(f"Error generating briefing: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to generate briefing: {str(e)}")


# =============================================================================
# Manual Input Endpoints
# =============================================================================


@router.post("/inputs", response_model=ManualInputResponse)
async def create_manual_input_endpoint(input_data: ManualInputCreate):
    """
    Add a manual input for consideration in future briefings.

    Manual inputs allow admins to inject external sources (blogs, tweets,
    reports) that should be considered by the briefing agent.

    Args:
        input_data: The manual input to add

    Returns:
        ManualInputResponse with the created input
    """
    try:
        input_doc = {
            "title": input_data.title,
            "source_type": input_data.source_type,
            "content": input_data.content,
            "url": input_data.url,
            "admin_notes": input_data.admin_notes,
        }

        input_id = await insert_manual_input(input_doc)

        # Fetch the created input
        db = await mongo_manager.get_async_database()
        created_input = await db.manual_inputs.find_one({"_id": input_id})

        if not created_input:
            raise HTTPException(status_code=500, detail="Failed to create input")

        return ManualInputResponse(
            _id=str(created_input["_id"]),
            title=created_input["title"],
            source_type=created_input["source_type"],
            content=created_input["content"],
            url=created_input.get("url"),
            admin_notes=created_input.get("admin_notes"),
            status=created_input["status"],
            added_at=created_input["added_at"].isoformat(),
            expires_at=created_input["expires_at"].isoformat(),
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Error creating manual input: {e}")
        raise HTTPException(status_code=500, detail="Failed to create manual input")


@router.get("/inputs", response_model=List[ManualInputResponse])
async def get_pending_manual_inputs_endpoint():
    """
    Get all pending manual inputs.

    Returns inputs that haven't been used yet and haven't expired.
    These will be considered by the briefing agent in the next generation.

    Returns:
        List of pending manual inputs
    """
    try:
        inputs = await get_pending_manual_inputs()

        return [
            ManualInputResponse(
                _id=str(inp["_id"]),
                title=inp["title"],
                source_type=inp["source_type"],
                content=inp["content"],
                url=inp.get("url"),
                admin_notes=inp.get("admin_notes"),
                status=inp["status"],
                added_at=inp["added_at"].isoformat(),
                expires_at=inp["expires_at"].isoformat(),
            )
            for inp in inputs
        ]

    except Exception as e:
        logger.exception(f"Error fetching pending inputs: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch pending inputs")


@router.delete("/inputs/{input_id}")
async def delete_manual_input_endpoint(input_id: str):
    """
    Delete a manual input.

    Args:
        input_id: MongoDB ObjectId of the input to delete

    Returns:
        Success message

    Raises:
        404: If input not found
    """
    try:
        deleted = await delete_manual_input(input_id)

        if not deleted:
            raise HTTPException(status_code=404, detail="Input not found")

        return {"status": "deleted", "input_id": input_id}

    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Error deleting manual input: {e}")
        raise HTTPException(status_code=500, detail="Failed to delete input")


# =============================================================================
# Feedback Endpoint
# =============================================================================


@router.get("/feedback")
async def get_active_feedback_endpoint():
    """
    Get the current active guidelines from the feedback file.

    Returns the admin-editable guidelines that influence briefing generation.
    """
    try:
        memory_manager = get_memory_manager()
        guidelines = memory_manager.get_active_guidelines()

        return {
            "guidelines": guidelines,
            "feedback_file": memory_manager.feedback_file_path,
        }

    except Exception as e:
        logger.exception(f"Error fetching feedback: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch feedback")
